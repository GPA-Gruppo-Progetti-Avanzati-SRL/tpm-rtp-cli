// Package {{.PackageName}}
// Do not Edit. This stuff it's been automatically generated.
package {{.PackageName}}

import (
    {{- range getComplexTypesImports .PackageName}}
    "{{ . }}"
    {{- end}}
	"errors"
	"reflect"
	"fmt"
)

{{ $packageName := .PackageName }}

func (d *Document) Set(path string, src interface{}) error {

    /*
	path = strings.TrimPrefix(path, "/Doc/")
	path = strings.Replace(path, "*", "", -1)
	path = strings.Replace(path, "[]", "", -1)
	path = strings.Replace(path, "/", ".", -1)
	*/

	v := reflect.ValueOf(d)
	fields := d.mapper.TraversalsByName(v.Type(), []string{path})

	values := make([]interface{}, 1)
	err := fieldsByTraversal(v, fields, values, true)
	if err != nil {
		return err
	}

	return copy2Dest(path, values[0], src)
}

/*
func convertAssignRows(dest, src interface{}) error {

	switch d := dest.(type) {
	case *common.Max35Text:
		if d == nil {
			return errors.New("nil pointer... in unmarshalling Max35Text data")
		}
		*d = common.MustToMax35Text(src)
		return nil
	}
	return nil
}
*/

{{ $types := typesVisit .PackageName }}
func copy2Dest(docPath string, dest, src interface{}) error {

	var err error
	switch typedDest := dest.(type) {
{{- range $nm, $tp := $types.Types}}
{{- if not $tp.IsStruct }}
  case *{{$tp.TypeWithPackageTrimmed $packageName}}:
        if typedDest == nil {
  			return errors.New("nil pointer... in unmarshalling {{$tp.TypeWithPackageTrimmed $packageName}} data for" + docPath)
	    }

  		*typedDest, err = {{$tp.NameOfTypeFunction "To" $packageName }}(src)
  		return err
{{- end }}
{{- end }}
   default:
        return fmt.Errorf("could not find the type to node %s of type %v", docPath, dest)
 }

 return nil
}

